name: dev-deploy-v2

on:
  workflow_dispatch:
    inputs:
      aws_region:
        description: "AWS region"
        required: false
        default: "ap-northeast-1"
      image_tag:
        description: "Backend image tag"
        required: false
        default: "manual"
      api_domain:
        description: "API domain (optional override)"
        required: false
        default: ""
      ecr_backend_repo:
        description: "ECR backend repo (optional override)"
        required: false
        default: ""
      ecs_cluster_name:
        description: "ECS cluster name (optional override)"
        required: false
        default: ""
      ecs_service_name:
        description: "ECS service name (optional override)"
        required: false
        default: ""

permissions:
  id-token: write
  contents: read

concurrency:
  group: dev-deploy-v2
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Guard branch
        if: ${{ github.ref_name != 'dev' }}
        run: |
          echo "[ERROR] run this workflow on dev branch."
          echo "current ref: ${{ github.ref_name }}"
          exit 1

      - name: Resolve config
        id: cfg
        shell: bash
        run: |
          set -euo pipefail

          trim_value() {
            local v="$1"
            v="$(echo "$v" | tr -d '\r\n' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
            echo "$v"
          }

          normalize_host() {
            local v="$1"
            v="${v#http://}"
            v="${v#https://}"
            v="${v%%/*}"
            v="${v%%:*}"
            echo "$v"
          }

          AWS_REGION_INPUT="$(trim_value "${{ github.event.inputs.aws_region }}")"
          IMAGE_TAG_INPUT="$(trim_value "${{ github.event.inputs.image_tag }}")"
          ROLE_ARN="$(trim_value "${{ vars.AWS_ROLE_TO_ASSUME_DEV_DEPLOY }}")"
          STATE_BUCKET="$(trim_value "${{ vars.TF_STATE_BUCKET }}")"
          ROOT_DOMAIN_RAW="$(trim_value "${{ vars.ROOT_DOMAIN }}")"
          API_DOMAIN_INPUT_RAW="$(trim_value "${{ github.event.inputs.api_domain }}")"
          API_DOMAIN_VAR_RAW="$(trim_value "${{ vars.DEV_API_DOMAIN }}")"
          ECS_CLUSTER_INPUT="$(trim_value "${{ github.event.inputs.ecs_cluster_name }}")"
          ECS_CLUSTER_VAR="$(trim_value "${{ vars.DEV_ECS_CLUSTER_NAME }}")"
          ECS_SERVICE_INPUT="$(trim_value "${{ github.event.inputs.ecs_service_name }}")"
          ECS_SERVICE_VAR="$(trim_value "${{ vars.DEV_ECS_SERVICE_NAME }}")"
          ECR_BACKEND_REPO_INPUT="$(trim_value "${{ github.event.inputs.ecr_backend_repo }}")"
          ECR_BACKEND_REPO_VAR="$(trim_value "${{ vars.DEV_ECR_BACKEND_REPO }}")"

          ROOT_DOMAIN="$(normalize_host "$ROOT_DOMAIN_RAW")"
          API_DOMAIN_RAW="$API_DOMAIN_INPUT_RAW"
          if [ -z "$API_DOMAIN_RAW" ]; then
            API_DOMAIN_RAW="$API_DOMAIN_VAR_RAW"
          fi
          API_DOMAIN="$(normalize_host "$API_DOMAIN_RAW")"
          ECS_CLUSTER_NAME="$ECS_CLUSTER_INPUT"
          if [ -z "$ECS_CLUSTER_NAME" ]; then
            ECS_CLUSTER_NAME="$ECS_CLUSTER_VAR"
          fi
          ECS_SERVICE_NAME="$ECS_SERVICE_INPUT"
          if [ -z "$ECS_SERVICE_NAME" ]; then
            ECS_SERVICE_NAME="$ECS_SERVICE_VAR"
          fi
          ECR_BACKEND_REPO="$ECR_BACKEND_REPO_INPUT"
          if [ -z "$ECR_BACKEND_REPO" ]; then
            ECR_BACKEND_REPO="$ECR_BACKEND_REPO_VAR"
          fi

          if [ -z "$API_DOMAIN" ] && [ -n "$ROOT_DOMAIN" ]; then
            API_DOMAIN="api-dev.${ROOT_DOMAIN}"
          fi
          if [ -z "$ECS_CLUSTER_NAME" ]; then
            ECS_CLUSTER_NAME="enm-dev-cluster"
          fi
          if [ -z "$ECS_SERVICE_NAME" ]; then
            ECS_SERVICE_NAME="enm-dev-api"
          fi
          if [ -z "$ECR_BACKEND_REPO" ]; then
            ECR_BACKEND_REPO="enm/backend"
          fi

          for kv in \
            "AWS_REGION_INPUT:$AWS_REGION_INPUT" \
            "IMAGE_TAG_INPUT:$IMAGE_TAG_INPUT" \
            "ROLE_ARN:$ROLE_ARN" \
            "STATE_BUCKET:$STATE_BUCKET" \
            "ROOT_DOMAIN:$ROOT_DOMAIN"
          do
            key="${kv%%:*}"
            val="${kv#*:}"
            if [ -z "$val" ]; then
              echo "[ERROR] missing required value: $key"
              exit 1
            fi
          done

          if [[ ! "$ROLE_ARN" =~ ^arn:aws:iam::[0-9]{12}:role/.+ ]]; then
            echo "[ERROR] invalid AWS role ARN format: $ROLE_ARN"
            exit 1
          fi
          if [[ ! "$IMAGE_TAG_INPUT" =~ ^[A-Za-z0-9_][A-Za-z0-9._-]{0,127}$ ]]; then
            echo "[ERROR] invalid image_tag format: $IMAGE_TAG_INPUT"
            echo "Allowed: alnum/underscore start, then alnum/._- up to 128 chars."
            exit 1
          fi

          echo "aws_region=$AWS_REGION_INPUT" >> "$GITHUB_OUTPUT"
          echo "image_tag=$IMAGE_TAG_INPUT" >> "$GITHUB_OUTPUT"
          echo "aws_role_to_assume=$ROLE_ARN" >> "$GITHUB_OUTPUT"
          echo "tf_state_bucket=$STATE_BUCKET" >> "$GITHUB_OUTPUT"
          echo "root_domain=$ROOT_DOMAIN" >> "$GITHUB_OUTPUT"
          echo "api_domain=$API_DOMAIN" >> "$GITHUB_OUTPUT"
          echo "ecs_cluster_name=$ECS_CLUSTER_NAME" >> "$GITHUB_OUTPUT"
          echo "ecs_service_name=$ECS_SERVICE_NAME" >> "$GITHUB_OUTPUT"
          echo "ecr_backend_repo=$ECR_BACKEND_REPO" >> "$GITHUB_OUTPUT"

      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.cfg.outputs.aws_role_to_assume }}
          aws-region: ${{ steps.cfg.outputs.aws_region }}

      - name: Terraform init (dev)
        run: |
          terraform -chdir=infra/terraform/envs/dev init -reconfigure \
            -backend-config="bucket=${{ steps.cfg.outputs.tf_state_bucket }}" \
            -backend-config="key=enm/dev/terraform.tfstate" \
            -backend-config="region=${{ steps.cfg.outputs.aws_region }}" \
            -backend-config="encrypt=true" \
            -input=false

      - name: Validate ECR image tag exists
        shell: bash
        run: |
          set -euo pipefail
          aws ecr describe-images \
            --repository-name "${{ steps.cfg.outputs.ecr_backend_repo }}" \
            --image-ids "imageTag=${{ steps.cfg.outputs.image_tag }}" \
            --region "${{ steps.cfg.outputs.aws_region }}" \
            --query 'imageDetails[0].imageDigest' \
            --output text >/dev/null

      - name: Terraform plan (dev)
        run: |
          terraform -chdir=infra/terraform/envs/dev plan \
            -input=false \
            -out=tfplan \
            -var "root_domain=${{ steps.cfg.outputs.root_domain }}" \
            -var "shared_state_bucket=${{ steps.cfg.outputs.tf_state_bucket }}" \
            -var "shared_state_key=enm/shared/terraform.tfstate" \
            -var "shared_state_region=${{ steps.cfg.outputs.aws_region }}" \
            -var "runtime_enabled=true" \
            -var "create_dns_records=true" \
            -var "api_image_tag=${{ steps.cfg.outputs.image_tag }}"

      - name: Terraform apply (dev)
        run: terraform -chdir=infra/terraform/envs/dev apply -input=false -auto-approve tfplan

      - name: Wait for ECS service stable
        run: |
          aws ecs wait services-stable \
            --cluster "${{ steps.cfg.outputs.ecs_cluster_name }}" \
            --services "${{ steps.cfg.outputs.ecs_service_name }}" \
            --region "${{ steps.cfg.outputs.aws_region }}"

      - name: Health check (ALB and API domain)
        shell: bash
        env:
          API_DOMAIN: ${{ steps.cfg.outputs.api_domain }}
        run: |
          set -euo pipefail

          ALB_DNS="$(terraform -chdir=infra/terraform/envs/dev output -raw alb_dns_name)"
          if [ -z "$ALB_DNS" ]; then
            echo "[ERROR] alb_dns_name is empty."
            exit 1
          fi

          check_with_retry() {
            local name="$1"
            local url="$2"
            local attempts=20
            local sleep_sec=15

            for ((i=1; i<=attempts; i++)); do
              echo "[$name] attempt $i/$attempts: $url"
              if body="$(curl -fsS --max-time 20 "$url")"; then
                echo "$body"
                if [[ "$body" == *'"status":"ok"'* ]]; then
                  echo "[OK] $name"
                  return 0
                fi
              fi
              sleep "$sleep_sec"
            done

            echo "[ERROR] $name health check failed: $url"
            return 1
          }

          check_with_retry "ALB" "http://${ALB_DNS}/health"
          check_with_retry "API-Domain" "http://${API_DOMAIN}/health"

      - name: Show ECS recent events on failure
        if: failure()
        run: |
          aws ecs describe-services \
            --cluster "${{ steps.cfg.outputs.ecs_cluster_name }}" \
            --services "${{ steps.cfg.outputs.ecs_service_name }}" \
            --region "${{ steps.cfg.outputs.aws_region }}" \
            --query "services[0].events[0:15].[createdAt,message]" \
            --output table || true

      - name: Summary
        if: always()
        run: |
          echo "image_tag: ${{ steps.cfg.outputs.image_tag }}"
          echo "aws_region: ${{ steps.cfg.outputs.aws_region }}"
          echo "api_domain: ${{ steps.cfg.outputs.api_domain }}"
          echo "ecs_cluster_name: ${{ steps.cfg.outputs.ecs_cluster_name }}"
          echo "ecs_service_name: ${{ steps.cfg.outputs.ecs_service_name }}"

      - name: Notify Discord (success)
        if: success()
        shell: bash
        env:
          DISCORD_WEBHOOK: ${{ secrets.DEV_DEPLOY_DISCORD_WEBHOOK }}
        run: |
          set -euo pipefail
          WEBHOOK="$(echo "${DISCORD_WEBHOOK:-}" | tr -d '\r\n' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
          if [ -z "$WEBHOOK" ]; then
            echo "[INFO] DEV_DEPLOY_DISCORD_WEBHOOK is empty; skip notify."
            exit 0
          fi
          if [[ ! "$WEBHOOK" =~ ^https://discord\.com/api/webhooks/[0-9]+/.+ ]]; then
            echo "[WARN] DEV_DEPLOY_DISCORD_WEBHOOK format looks invalid; skip notify."
            exit 0
          fi

          RUN_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          MSG="[成功] dev-deploy-v2 が完了しました
          リポジトリ: ${{ github.repository }}
          ブランチ: ${{ github.ref_name }}
          image_tag: ${{ steps.cfg.outputs.image_tag }}
          実行URL: ${RUN_URL}"

          if ! jq -n --arg content "$MSG" '{content: $content}' | \
            curl -fsS -X POST -H "Content-Type: application/json" --data @- "$WEBHOOK"; then
            echo "[WARN] Discord notify failed; continue."
          fi

      - name: Notify Discord (failure)
        if: failure()
        shell: bash
        env:
          DISCORD_WEBHOOK: ${{ secrets.DEV_DEPLOY_DISCORD_WEBHOOK }}
        run: |
          set -euo pipefail
          WEBHOOK="$(echo "${DISCORD_WEBHOOK:-}" | tr -d '\r\n' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
          if [ -z "$WEBHOOK" ]; then
            echo "[INFO] DEV_DEPLOY_DISCORD_WEBHOOK is empty; skip notify."
            exit 0
          fi
          if [[ ! "$WEBHOOK" =~ ^https://discord\.com/api/webhooks/[0-9]+/.+ ]]; then
            echo "[WARN] DEV_DEPLOY_DISCORD_WEBHOOK format looks invalid; skip notify."
            exit 0
          fi

          RUN_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          MSG="[失敗] dev-deploy-v2 が失敗しました
          リポジトリ: ${{ github.repository }}
          ブランチ: ${{ github.ref_name }}
          image_tag: ${{ steps.cfg.outputs.image_tag }}
          実行URL: ${RUN_URL}"

          if ! jq -n --arg content "$MSG" '{content: $content}' | \
            curl -fsS -X POST -H "Content-Type: application/json" --data @- "$WEBHOOK"; then
            echo "[WARN] Discord notify failed; continue."
          fi
